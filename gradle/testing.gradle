// install the CLI, either from source code directly or from a GH release, before starting tests
task runInstallForTesting(type: Exec) {
    boolean testInstallFromGitHub = project.hasProperty('testInstallFromGitHub')
    String installMode = testInstallFromGitHub ? 'GITHUB_RELEASE' : 'SOURCE_CODE'
    commandLine 'bash', './tools/install-for-testing.sh', installMode, "${gradle.cliVersion}"

    dependsOn installDist
}

// Builds and returns a complete list of test tags to be executed on
//      testType:       'unit' / 'integration'      -> not null
//      testTag:        input from gradle command   -> not null
//      cloudPlatform:  input from gradle command   -> may be null
// in: unit / unit      / null  ->  out:    [unit, unit-gcp, unit-aws, unit-azure]
// in: unit / unit      / gcp   ->  out:    [unit, unit-gcp]
// in: unit / unit-gcp  / null  ->  out:    [unit-gcp]
// in: unit / unit-gcp  / gcp   ->  out:    [unit-gcp]
// in: unit / unit-gcp  / aws   ->  out:    []
static def getAllTestTagsToRun(String testType, String testTag, String cloudPlatform) {
    def allTestTags = []
    switch (testTag) {
        case testType:
            allTestTags.add(testType)
            if (cloudPlatform == 'gcp') {
                allTestTags.add(testType + '-gcp')
            } else if (cloudPlatform == 'aws') {
                allTestTags.add(testType + '-aws')
            } else if (cloudPlatform == 'azure') {
                allTestTags.add(testType + '-azure')
            } else if (cloudPlatform == null) {  // run all tests
                allTestTags.addAll([testType + '-gcp', testType + '-aws', testType + '-azure'])
            }
            break

        case testType + '-gcp':
            if ((cloudPlatform == 'gcp') || (cloudPlatform == null)) {
                allTestTags.add(testType + '-gcp')
            }
            break

        case testType + '-aws':
            if ((cloudPlatform == 'aws') || (cloudPlatform == null)) {
                allTestTags.add(testType + '-aws')
            }
            break

        case testType + '-azure':
            if ((cloudPlatform == 'azure') || (cloudPlatform == null)) {
                allTestTags.add(testType + '-azure')
            }
            break

        default:
            break // no tests
    }
    return allTestTags as String[]
}

// run tests with the specified tag and install mode.
// 1) run unit tests directly against the source code
//    ./gradlew runTestsWithTag -PtestTag=unit
// 2) run integration tests against an installation built from source code
//    ./gradlew runTestsWithTag -PtestTag=integration
// 3) run integration tests against an installation built from the latest GitHub release
//    ./gradlew runTestsWithTag -PtestTag=integration -PtestInstallFromGitHub
task runTestsWithTag(type: Test) {
    doFirst {
        // All gradle tasks are evaluated every time any task is run. If we
        // require that the testTag property be defined in this task definition,
        // gradle will fail any run which does not define this property, even
        // if the runTestsWithTag task isn't involved!

        // gradle project properties define which tests to run and how to do the install before running them
        String testTag = project.findProperty('testTag')
        // if the test tag is not defined, then throw an error. we don't know what tests to run
        if (testTag == null) {
            throw new GradleException('The testTag Gradle property is required (e.g. -PtestTag=unit, -PtestTag=integration)')
        }

        String testType = null
        if (testTag.startsWith('unit')) {
            testType = 'unit'

            // [for unit tests] specify the implementation version that's set in the JAR manifest. unit tests
            // run against the code directly, and so there is no JAR manifest. this implementation version is
            // used to get the default docker image id.
            systemProperty('TERRA_JAR_IMPLEMENTATION_VERSION',
                    "${project.properties['dockerRepoPath']}/${project.properties['dockerImageName']}/${gradle.cliVersion}:${project.properties['dockerImageTag']}")
            // Normally CLI version comes from jar. For unit tests, there is no jar, so pass version this way.
            systemProperty('TERRA_CLI_VERSION', "${gradle.cliVersion}")

        } else if (testTag.startsWith('real-unit')) {
            testType = 'real-unit'

            // Same as unit tests
            systemProperty('TERRA_JAR_IMPLEMENTATION_VERSION',
                    "${project.properties['dockerRepoPath']}/${project.properties['dockerImageName']}/${gradle.cliVersion}:${project.properties['dockerImageTag']}")
            // Normally CLI version comes from jar. For unit tests, there is no jar, so pass version this way.
            systemProperty('TERRA_CLI_VERSION', "${gradle.cliVersion}")
        } else if (testTag.startsWith('integration')) {
            testType = 'integration'

            // [for integration tests] specify the install location for the terra application (i.e. launch script)
            // for an installation directly from source code, this points to the build/install/terra-cli/bin directory (i.e. the output of ./gradlew install)
            // for an installation from a GH release, this points to the build/test-install directory (i.e. where the curl install command is run)
            boolean testInstallFromGitHub = project.hasProperty('testInstallFromGitHub')
            String installDir = testInstallFromGitHub ? "${project.buildDir}/test-install" : "${project.buildDir}/install/${gradle.projectGroup}/bin"
            systemProperty('TERRA_INSTALL_DIR', installDir)

            // [for integration tests] specify the working directory to use when running scripts. this makes
            // it easier to clean up after tests (./gradlew clean) that generate files.
            mkdir "${project.buildDir}/test-working-dir/"
            systemProperty('TERRA_WORKING_DIR', "${project.buildDir}/test-working-dir/")
        }else {
            throw new GradleException("Unknown test tag: ${testTag}")
        }

        // tell junit to run tests with this tag: unit or integration
        useJUnitPlatform {
            includeTags getAllTestTagsToRun(testType, testTag, project.findProperty('platform'))
        }

        // We don't want to use up all the cores on a developer's machine because it locks them out of doing other
        // work, but that's not a concern for dedicated CI machines.
        int localCores = System.getenv().containsKey('CI') ? Runtime.runtime.availableProcessors() : Runtime.runtime.availableProcessors().intdiv(2)
        // Integration tests wrap various external command-line tools which often maintain their own global state.
        // Running them in parallel will cause runners to clobber this state, so these tests must be run serially.
        maxParallelForks = (testType == 'integration') ? 1 : localCores
    }

    beforeTest { descriptor ->
        println '========================================================='
        println "Running test: ${descriptor.name} [${descriptor.className}]"
    }
    afterTest { descriptor, result ->
        println "Finished running test ${descriptor.name} [${descriptor.className}] with result: ${result.resultType}"
    }
    testLogging {
        showStandardStreams = true // disable stdout & stderr redirection
    }

    boolean contextDir = project.hasProperty('contextDir')

    // by default, tests override the global context directory with a sub-directory of the gradle build directory
    // this makes it easier to clean up after tests and makes sure the tests don't overwrite any context that
    // exists on this same machine. you can override this default behavior by specifying -PcontextDir=/path/to/dir.
    // this will cause context to be written to the specified directory.
    if (!contextDir) {
        environment 'TERRA_CONTEXT_PARENT_DIR', "${buildDir}/test-context/"
        mkdir "${project.buildDir}/test-context/"
    } else {
        environment 'TERRA_CONTEXT_PARENT_DIR', project.findProperty('contextDir')
    }

    // specify the server to run tests against (e.g. -Pserver=verily-devel). defaults to 'broad-dev'
    String terraServer = project.hasProperty('server') ? project.findProperty('server') : 'broad-dev'
    environment 'TERRA_SERVER', terraServer

    // set which file in src/test/resources/testconfigs to use
    String terraTestConfigName = project.hasProperty('testConfig') ? project.findProperty('testConfig') : 'broad'
    systemProperty('TERRA_TEST_CONFIG_NAME', terraTestConfigName)

    // suppress console logging ('stdin' & 'stdout' display)
    String terraTestQuietConsole = project.hasProperty('quietConsole') ? 'true' : 'false'
    systemProperty('TERRA_TEST_QUIET_CONSOLE', terraTestQuietConsole)

    // specify the Docker image to run tests with (e.g. -PdockerImage=terra-cli/local:b5fdce0). if unspecified, tests use the default Docker image
    String terraDockerImage = project.hasProperty('dockerImage') ? project.findProperty('dockerImage') : ''
    environment 'TERRA_DOCKER_IMAGE', terraDockerImage

    // generate a unique id for each test run
    systemProperty('TEST_RUN_ID', UUID.randomUUID().toString())

    // run the install-for-testing.sh script before any tests
    dependsOn runInstallForTesting

    finalizedBy jacocoTestReport

    outputs.upToDateWhen { false } // force tests to always be re-run

    // TODO(PF-2465): Re-enable retries once flakiness is under control.
    //    retry {
    //        // This is set automatically on Github Actions runners, and never set
    //        // otherwise.
    //        if (System.getenv().containsKey('CI')) {
    //            // Max retries per test.
    //            maxRetries = 1
    //            // Max total test failures.
    //            // This is an estimate based on current failure rates, but if more
    //            // than 5 tests fail in a run it's likely a real source of failure
    //            // and we should stop retrying.
    //            maxFailures = 5
    //        }
    //        failOnPassedAfterRetry = true
    //    }
}

// cleanup workspaces owned by test users.
// 1) do a dry run (i.e. don't actually try to delete anything)
//    ./gradlew cleanupTestUserWorkspaces -Pserver=broad-dev -PtestConfig=broad -PdryRun
// 2) try to delete each workspace owned by a test user
//    ./gradlew cleanupTestUserWorkspaces -Pserver=broad-dev -PtestConfig=broad
task cleanupTestUserWorkspaces(type: JavaExec) {
    classpath sourceSets.test.runtimeClasspath
    mainClass = 'harness.utils.CleanupTestUserWorkspaces'

    // override the default global context directory with a sub-directory of the gradle build directory
    // this is so that the tests don't overwrite any context that exists on this same machine.
    environment 'TERRA_CONTEXT_PARENT_DIR', "${buildDir}/test-context/"
    mkdir "${project.buildDir}/test-context/"

    // [required] specify the server to cleanup (e.g. -Pserver=broad-dev). no default value, force caller to specify this
    systemProperty('TERRA_SERVER', project.findProperty('server'))

    // set which file in src/test/resources/testconfigs to use
    String terraTestConfigName = project.hasProperty('testConfig') ? project.findProperty('testConfig') : 'broad'
    systemProperty('TERRA_TEST_CONFIG_NAME', terraTestConfigName)

    // suppress console logging ('stdin' & 'stdout' display)
    String terraTestQuietConsole = project.hasProperty('quietConsole') ? 'true' : 'false'
    systemProperty('TERRA_TEST_QUIET_CONSOLE', terraTestQuietConsole)

    // [optional] specify that this is a dry run (e.g. -PdryRun)
    systemProperty('DRY_RUN', project.hasProperty('dryRun').toString())

    dependsOn compileJava
}
