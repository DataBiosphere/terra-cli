# terra-cli

1. [Setup development environment](#setup-development-environment)
    * [Logging](#logging)
    * [Troubleshooting](#troubleshooting)
2. [Publish a release](#publish-a-release)
3. [Docker](#docker)
    * [Pull an existing image](#pull-an-existing-image)
    * [Build a new image](#build-a-new-image)
    * [Publish a new image](#publish-a-new-image)
    * [Update the default image](#update-the-default-image)
4. [Code structure](#code-structure)
    * [Servers](#servers)
    * [Command structure](#command-structure)
    * [Context classes](#context-classes)
    * [Supported tools](#supported-tools)
5. [Adding a new supported tool](#adding-a-new-supported-tool)

-----

### Setup development environment
From the top-level directory:
```
source tools/local-dev.sh
terra
```

#### Logging
Logging is turned off by default. Modify the root level in the `src/main/resources/logback.xml` file to turn it on (e.g. `INFO`).

#### Troubleshooting
- Wipe the global context directory. `rm -R $HOME/.terra`.
- Re-run the setup script. `source tools/local-dev.sh`.


### Publish a release
A release includes a GitHub release of the `terra-cli` repository and a corresponding Docker image pushed to GCR.

To publish a release manually, from the current local code:
1. Create a tag (e.g. `test123`) and push it to the remote repository. The tag should not include any uppercase letters.
    ```
    > git tag -a test123 -m "testing version 123"
    > git push --tags
    ```
2. Update the version in `build.gradle`.
    ```
    version = 'test123'
    ```
3. Login to GitHub and run the `tools/publish-release.sh` script. This will publish a pre-release, which does not
affect the "Latest release" tag.
    ```
    > gh auth login
    > ./tools/publish-release.sh test123
    ```
    To publish a regular release, add `true` as a second argument.
     ```
    > gh auth login
    > ./tools/publish-release.sh test123 true
    ```

Note that GitHub automatically attaches an archive of the source code to the release. If you have local changes that
are not yet committed, then they may not be reflected in the source code archive, but they will be included in the
install package. We don't use the source code archive for install.

#### Install overview
Three shell scripts are published for users.

##### `download-install.sh`
This is convenience script that:
- Downloads the latest (or specific version) of the install package
- Unarchives it
- Runs the `install.sh` script included inside
- Deletes the install package

It is published as a separate file in each GitHub release.
The intent is to have a one-line install command  `curl -L download-install.sh | bash`.

Note that this installs the CLI in the current directory. Afterwards, the user can optionally add it to their `$PATH`.

##### `install.sh`
This is an installer script that:
- Moves all the JARs to `$HOME/.terra/lib`
- Moves the `terra` run script and the `README.md` file outside the unarchived install package directory
- Deletes the unarchived install package directory
- Sets the Docker image id to the default
- Pulls the default Docker image id

It is included in the `terra-cli.tar` install package in each GitHub release.
It needs to be run from the same directory: `./install.sh`

##### `terra`
This is the run script that wraps the Java call to the CLI.
- It looks for the JARs on the classpath in the `$HOME/.terra/lib` directory.
- This script is generated by the Gradle application plugin, so any changes should be made there.

It is included in the `terra-cli.tar` install package in each GitHub release.
This is the script users can add to their `$PATH` to invoke the CLI more easily from another directory.


### Docker
The `docker/` directory contains files required to build the Docker image.
All files in the `scripts/` sub-directory are copied to the image, into a sub-directory that is on the `$PATH`, 
and made executable.

Merging a PR and installing should take care of all this Docker image stuff for you, so these notes are mostly useful
for debugging/development when you need to make an image available outside of that normal process.
- The `tools/local-dev.sh` and `install.sh` scripts pull the default image.
- The `tools/publish-release.sh` script builds and publishes a new image. It also updates the image path that the CLI
uses to point to this newly published image.

#### Pull an existing image
The gcr.io/terra-cli-dev registry is public readable, so anyone should be able to pull images.

To use a specific Docker image from GCR:
1. Pull the image with that tag.
    ```
    > docker pull gcr.io/terra-cli-dev/terra-cli/v0.0:b5fdce0
    ```
2. Update the image id that the CLI uses.
    ```
    > terra config set image --image=gcr.io/terra-cli-dev/terra-cli/v0.0:b5fdce0
    ```

#### Build a new image
For any change in the `docker/` directory to take effect:
1. Build a new image. This uses a short Git hash for the current commit as the tag. See the script comments for more
options.
    ```
    > ./tools/build-docker.sh
   
    Generating an image tag from the Git commit hash
    Building the image
    [...Docker output...]
    Successfully built 6558c3bcb316
    Successfully tagged terra-cli/local:92d6e09
    terra-cli/local:92d6e09 successfully built
    ```
2. Update the image id that the CLI uses. (See output of previous command for image name and tag.)
    ```
    > terra config set image --image=terra-cli/local:b5fdce0
    ```

#### Publish a new image
To publish a new image to GCR:
1. Build the image (see above).
2. Render the CI credentials from Vault, in order to upload to GCR.
    ```
    > ./tools/render-config.sh
    ```
3. Push it to GCR. (See output of build command for local image tag.) See the script comments for more options.
    ```
    > ./tools/publish-docker.sh 92d6e09 "terra-cli/test" 92d6e09
      
    Logging in to docker using the CI service account key file
    Login Succeeded
    Tagging the local docker image with the name to use in GCR
    Logging into to gcloud and configuring docker with the CI service account
    Activated service account credentials for: [dev-ci-sa@broad-dsde-dev.iam.gserviceaccount.com]
    Pushing the image to GCR
    [...Docker push output...]
    92d6e09: digest: sha256:f419d97735749573baff95247d0918d174cb683089c9b1370e7c99817b9b6d67 size: 2211
    Restoring the current gcloud user
    Updated property [core/account].
    gcr.io/terra-cli-dev/terra-cli/test:92d6e09 successfully pushed to GCR
    ```
4. Pull the image from GCR (see above). This is so that the name and tag on your local image matches what it will
look like for someone who did not build the image.

#### Update the default image
It's best to do this as part of a release, but if it's necessary to update the default image manually:
1. Publish the image (see above).
2. Update the `DockerAppsRunner.defaultImageId` method in the Java code to return a hard-coded string.


### Code structure
Below is an outline of the directory structure. Details about each are included in the sub-sections below.
```
src/main/
  java/
    bio/terra/cli/
      apps/
        interfaces/
      auth/
      command/
      context/
      service/
  resources/
      servers/
```

#### Servers
The `src/main/java/resources/servers/` directory contains the server specification files.
Each file specifies a Terra environment, or set of connected Terra services, and maps to an instance of the 
`ServerSpecification` class.

The `ServerSpecification` class closely follows the Test Runner class of the same name.
There's no need to keep these classes exactly in sync, but that may be a good place to consult when expanding the 
class here.

To add a new server specification, create a new file in this directory and add the file name to the `all-servers.json` 
file.

#### Command structure
The `src/main/java/bio/terra/cli/command/` directory contains the hierarchy of the commands as they appear to the user.
With the exception of the `app/supported` sub-directory, the directory structure matches the command hierarchy.

`Main` is the top-level command and child commands are defined in class annotations.
Most of the top-level commands (e.g. `auth`, `server`, `workspace`) are strictly for grouping; the command itself 
doesn't do anything.
An empty class body with child commands defined in the annotation creates such a grouping command.

Supported tools are currently children of the top-level command, but are hidden from the usage help.

#### Context classes
The `src/main/java/bio/terra/cli/context/` directory contains the objects that represent the current state.
Since the CLI Java code exits after each command, this state is persisted on disk by the `GlobalContext` and 
`WorkspaceContext` classes.

Other packages (e.g. `src/main/java/bio/terra/cli/app/`, `auth/`, `server/` and `workspace/`) contain classes that 
manipulate the context objects. Classes are grouped into packages by general functional area.

#### Supported tools
The `src/main/java/bio/terra/cli/apps/` directory contains (external) tools that the CLI supports.
Currently these tools can be called from the top-level, so it looks the same as it would if you called it on your 
local terminal, only with a `terra` prefix. For example:
```
terra gsutil ls
terra bq version
terra nextflow run hello
```

The list of supported tools that can be called is specified in an enum in the `terra app list` class.

### Add a new supported tool
To add a new supported tool:
   1. Install the app in the `docker/Dockerfile`
   2. Build the new image (see instructions in section above).
   3. Test that the install worked by calling the app through the `terra app execute` command.
   (e.g. `terra app execute dsub --version`). This command just runs the Docker container and 
   executes the command, without requiring any new Java code. This `terra app execute` command
   is intended for debugging only; this won't be how users call the tool.
   4. Add a new command class in the `src/main/java/bio/terra/cli/command/app/passthrough` package.
   Copy/paste an existing class in that same package as a starting point. Gsutil, Bq, and Gcloud 
   are the simplest.
   5. Add it to the list of tools shown by `terra app list` by adding the new command class to
   the list of sub-commands in the `@Command` annotation of the `Main.class`. This means you can
   invoke the command by prefixing it with terra (e.g. `terra dsub -version`).
   6. When you run e.g. `terra dsub -version`, the CLI:
      - Launches a Docker container
      - Runs the `terra_init.sh` script in the `docker/scripts` directory, which activates the user’s
      pet service account and sets the workspace project
      - Runs the dsub command
   7. You can pass environment variables through to the Docker container by populating a `Map` and
   passing it to the `DockerAppsRunner.runToolCommand` method. Two environment variables are always
   passed:
       - `GOOGLE_CLOUD_PROJECT` = the workspace project id
       - `GOOGLE_APPLICATION_CREDENTIALS` = the pet service account key file
   8.  You can mount directories on the host machine to the Docker container by populating a second
   `Map` and passing it to the same `DockerAppsRunner.runToolCommand` method. The `nextflow` command
   has an example of this (see `bio.terra.cli.apps.Nextflow` class `run` method).
   9. Publish the new Docker image and update the default image that the CLI uses to the new version
   (see instructions in section above).
