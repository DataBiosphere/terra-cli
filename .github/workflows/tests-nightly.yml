name: Run tests nightly
on:
  workflow_dispatch: { }
  schedule:
  - cron: '0 5 * * *' # 5AM UTC = 12AM EST

env:
  GITHUB_TOKEN: ${{ secrets.BROADBOT_GITHUB_TOKEN }}

jobs:
  test-source-and-install:
    strategy:
      matrix:
        testServer: [ "broad-dev" ]
      fail-fast: false
    runs-on: ubuntu-latest

    steps:
    - name: Checkout current code
      uses: actions/checkout@v2
      with:
        token: ${{ GITHUB_TOKEN }}
    - name: Setup JDK
      uses: ./.github/actions/setup_jdk
    - name: Cache Gradle packages
      uses: ./.github/actions/cache_gradle
    - name: Render config
      uses: ./.github/actions/render_config

    - name: Run unit tests
      id: run_unit_tests
      if: always()
      run: |
        echo "Running unit tests for server: ${{ matrix.testServer }}"
        mkdir -p ~/logs-unit
        ./gradlew runTestsWithTag -PtestTag=unit --scan -Pserver=${{ matrix.testServer }} -PcontextDir=$HOME/logs-unit
    - name: Run integration tests against source code
      id: run_integration_tests_against_source_code
      if: always()
      run: |
        echo "Running integration tests against source code for server: ${{ matrix.testServer }}"
        mkdir -p ~/logs-integration-source
        ./gradlew runTestsWithTag -PtestTag=integration --scan -Pserver=${{ matrix.testServer }} -PcontextDir=$HOME/logs-integration-source
    - name: Run integration tests against release
      id: run_integration_tests_against_release
      if: always()
      run: |
        echo "Running integration tests against release for server: ${{ matrix.testServer }}"
        mkdir -p ~/logs-integration-release
        ./gradlew runTestsWithTag -PtestTag=integration --scan -PtestInstallFromGitHub -Pserver=${{ matrix.testServer }} -PcontextDir=$HOME/logs-integration-release
    - name: Compile logs and context files for all test runs
      id: compile_logs_and_context_files
      if: always()
      run: |
        declare -a arr=("integration-source" "integration-release")
        for i in "${arr[@]}"
        do
          echo "Compiling logs and context files for test run: $i"
          mkdir -p ~/to-archive/$i
          cp -R ~/logs-$i/.terra/logs/ ~/to-archive/$i/logs/
          cp -R ~/logs-$i/.terra/context.json ~/to-archive/$i/context.json
        done
        # Unit tests write to worker-specific directories, extract those here
        mkdir -p ~/to-archive/unit
        for N in `ls ~/logs-unit`
        do
          mkdir -p ~/to-archive/unit/$N
          cp -R ~/logs-unit/$N/.terra/logs/ ~/to-archive/unit/$N/logs/
          cp -R ~/logs-unit/$N/.terra/context.json ~/to-archive/unit/$N/context.json
        done
    - name: Archive logs and context file for all test runs
      id: archive_logs_and_context
      if: always()
      uses: actions/upload-artifact@v2
      with:
        name: logs-and-context-${{ matrix.testServer }}
        path: |
          ~/to-archive/
    - name: Compose status message
      id: compose_status_message
      if: always()
      run: |
        title="CLI nightly test run: ${{ matrix.testServer }}"
        L2="Unit: ${{ steps.run_unit_tests.outcome }} "
        L3="Integ (Source): ${{ steps.run_integration_tests_against_source_code.outcome }} "
        L4="Integ (Release): ${{ steps.run_integration_tests_against_release.outcome }}"
        bold="$L2 | $L3 | $L4"
        text="Link to <https://github.com/DataBiosphere/terra-cli/actions/runs/$GITHUB_RUN_ID|test run>"
        if [ "${{ job.status }}" == "success" ]; then
          text=":white_check_mark: $text"
        else
          text=":no_entry: $text"
        fi
        echo ::set-output name=status-title::$title
        echo ::set-output name=status-bold::$bold
        echo ::set-output name=status-text::$text
    - name: Notify PF alerts slack channel
      # don't notify manually triggered runs
      if: always() && github.event_name != 'workflow_dispatch'
      uses: broadinstitute/action-slack@v3.8.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        MATRIX_CONTEXT: ${{ toJson(matrix) }}
      with:
        status: ${{ job.status }}
        channel: "#platform-foundation-alerts"
        username: ${{ steps.compose_status_message.outputs.status-title }}
        author_name: ${{ steps.compose_status_message.outputs.status-bold }}
        icon_emoji: ':cli:'
        text: ${{ steps.compose_status_message.outputs.status-text }}
